#' Plot the multiscale MoB analysis output generated by \code{get_delta_stats}.
#' 
#' @param x a mob_out class object
#' @param stat a character string that specifies what statistic should be used
#'   in the effect size plots. Options include: \code{c('b0', 'b1', 'r', 'r2',
#'   'r2adj', 'f')} for the beta-coefficients, person correlation coefficient,
#'   r-squared, adjusted  r-squared, and F-statistic respectively. If the
#'   explanatory variable is a factor then \code{'b1'} is the only reasonable
#'   option. The default is set to the regression slope \code{'b1'} because this
#'   appears to have the strongest statistical power.
#' @param log2 a character string specifying if the x- or y-axis should be
#'   rescale by log base 2. Only applies when \code{display == 'S ~ effort' | 'S
#'   ~ effort'}. Options include: \code{c('', 'x', 'y', 'xy')} for  no
#'   rescaling, x-axis, y-axis, and both x and y-axes respectively. Default is
#'   set to no rescaling.
#' @param scale_by a character string specifying if sampling effort should be
#'   rescaled. Options include: \code{NULL}, \code{'indiv'}, and \code{'plot'}
#'   for no rescaling, rescaling to number of individuals, and rescaling
#'   to number of plots respectively. The rescaling is carried out using
#'   \code{mob_out$density_stat}.
#' @param display a string that specifies what graphical panels to display. 
#'  Options include:
#'  \itemize{
#'      \item \code{S ~ expl} ... plot of S versus the explanatory variable
#'      \item \code{S ~ effort} ... plot of S versus sampling effort (i.e., a
#'      rarefaction curve) 
#'      \item \code{effect ~ expl} ... plot of agg., N, and SAD effect size
#'      versus explanatory variable
#'      \item \code{stat ~ effort} ... plot of summary statistic versus sampling
#'      effort
#' }
#' Defaults to \code{'S ~ effort'}, \code{'effect ~ expl'}, and \code{'stat ~ effort'}.
#' @param eff_sub_effort Boolean which determines if only a subset of efforts
#'   will be considered in the plot of effect size (i.e., when
#'   \code{display = 'effect ~ expl'}. Defaults to TRUE to declutter the plots.
#' @param eff_log_base a positive real number that determines the base of the 
#'   logarithm that efforts were be distributed across, the larger this number
#'   the fewer efforts will be displayed.
#' @param eff_disp_pts Boolean to display the raw effect points, defaults to TRUE
#' @param eff_disp_smooth Boolean to display the regressions used to summarize
#'  the linear effect of the explanatory variable on the effect sizes, defaults
#'  to FALSE
#' @param ... parameters passed to other functions
#' 
#' @return plots the effect of the SAD, the number of individuals, and spatial
#'  aggregation on the difference in species richness
#'  
#' @author Dan McGlinn and Xiao Xiao
#' @import ggplot2 
#' @importFrom egg ggarrange
#' @importFrom stats predict loess lm
#' @importFrom grDevices rgb
#' @importFrom rlang .data
#' @export
#' @examples
#' data(inv_comm)
#' data(inv_plot_attr)
#' inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
#' inv_mob_out = get_delta_stats(inv_mob_in, 'group', ref_level='uninvaded',
#'                               type='discrete', log_scale=TRUE, n_perm=4)
#' plot(inv_mob_out, 'b1') 
#' \donttest{ 
#' plot(inv_mob_out, 'b1', scale_by = 'indiv')
#' }
#' 
#' 
#' 

plot(, stat = 'b1', scale_by = 'indiv',  # stat can be changed based on the wanted effect size method 
     eff_sub_effort = F, eff_log_base = 1,          # subset\all samples   #   
     eff_disp_pts = T,                              # T\P - show the raw effect points
     eff_disp_smooth = F) # T\F - show the linear effect of the expl var on the effect sizes



x <- delta_red
stat = 'b1'
log2 = ''
scale_by = 'indiv'
display = c('S ~ effort', 'effect ~ grad', 'stat ~ effort')
eff_sub_effort = F
eff_log_base = 1
eff_disp_pts = T
eff_disp_smooth = FALSE

plot.mob_out = function(x, stat = 'b1', log2 = '', scale_by = NULL, 
                        display = c('S ~ effort', 'effect ~ grad', 'stat ~ effort'),
                        eff_sub_effort = TRUE, eff_log_base = 2,
                        eff_disp_pts = TRUE, eff_disp_smooth = FALSE, ...) {
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar))
  if (x$type == 'discrete') {
    if (stat != 'b1')
      warning('The only statistic that has a reasonable interpretation for a discrete explanatory variable is the difference in the group means from the reference group (i.e., set stat = "b1")')
  }
  if (!is.null(scale_by)) {
    if (scale_by == 'indiv') {
      x$S_df = mutate(x$S_df, 
                      effort = ifelse(sample == 'plot', 
                                      round(.data$effort * x$density_stat$ind_dens),
                                      .data$effort))
      x$mod_df = mutate(x$mod_df, 
                        effort = ifelse(sample == 'plot', 
                                        round(.data$effort * x$density_stat$ind_dens),
                                        .data$effort))
      
    }     
    if (scale_by == 'plot') {
      x$S_df = mutate(x$S_df, 
                      effort = ifelse(sample == 'indiv', 
                                      round(.data$effort / x$density_stat$ind_dens),
                                      .data$effort))
      x$mod_df = mutate(x$mod_df, 
                        effort = ifelse(sample == 'indiv', 
                                        round(.data$effort / x$density_stat$ind_dens),
                                        .data$effort))
    } 
  }
  
  p_list = vector('list', 4)
  
  if ('S ~ grad' %in% display) {
    facet_labs = c(`agg` = 'sSBR',
                   `N` = 'nsSBR',
                   `SAD` = 'IBR')      
    p_list[[1]] = ggplot(x$S_df, aes(.data$env, .data$S)) +
      geom_smooth(aes(group = .data$effort, color = .data$effort),
                  method = 'lm', se = FALSE) +
      labs(x = x$env_var) +
      facet_wrap(. ~ test, scales = "free",
                 labeller = as_labeller(facet_labs))
  }
  
  if ('S ~ effort' %in% display) {
    facet_labs = c(`agg` = 'sSBR',
                   `N` = 'nsSBR',
                   `SAD` = 'IBR')
    p_list[[2]] = ggplot(x$S_df, aes(.data$effort, .data$S)) +
      geom_line(aes(group = .data$group, color = .data$env)) +
      facet_wrap(. ~ test, scales = "free",
                 labeller = as_labeller(facet_labs)) +
      labs(y = expression("richness (" *
                            italic(S) * ")"),
           color = x$env_var) 
  }
  
  if ('effect ~ grad' %in% display) {
    efforts = sort(unique(x$S_df$effort))
    if (is.logical(eff_sub_effort)) {
      if (eff_sub_effort) {
        # only show a subset of efforts for clarity
        effort_r = floor(log(range(efforts), eff_log_base))
        effort_2 = eff_log_base^(effort_r[1]:effort_r[2])
        effort_2 = effort_2[effort_2 > 1] # effort at 1 indiv uninformative
        eff_d = as.matrix(stats::dist(c(efforts, effort_2)))
        eff_d = eff_d[-((length(efforts) + 1):ncol(eff_d)),
                      -(1:length(efforts))]
        min_index = apply(eff_d, 2, function(x) which(x == min(x))[1])
        sub_effort = efforts[min_index]
        message(paste("Effect size shown at the following efforts:",
                      paste(sub_effort, collapse = ', ')))
      }
      else 
        sub_effort = efforts
    } else if (!is.null(eff_sub_effort))
      sub_effort = eff_sub_effort
    
    if (x$type == "continuous")
      x$S_df = x$S_df %>%
        group_by(.data$test, .data$effort) %>%
        mutate(low_effect = predict(loess(low_effect ~ .data$env), .data$env)) %>%
        mutate(high_effect = predict(loess(high_effect ~ .data$env), .data$env)) 
    
    
    p_list[[3]] = ggplot(subset(x$S_df, x$S_df$effort %in% sub_effort),
                         aes(.data$env, .data$effect)) +
      #geom_smooth(aes(x=group, y = med_effect,
      #                group = effort, color = effort),
      #            method = 'lm', se = FALSE) +
      #geom_ribbon(aes(ymin = low_effect, ymax = high_effect,
      #                group = effort, color = effort,
      #                fill = 'null'),
      #            alpha = .25) +
      geom_hline(yintercept = 0, linetype = 'dashed') + 
      labs(x = x$env_var) +
      facet_wrap(. ~ test, scales = "free_y") +
      labs(y = expression('effect (' * italic(S) * ')')) +
      scale_fill_manual(name = element_blank(),
                        values = c(null = 'grey40')) +
      scale_colour_gradient2(trans=scales::log2_trans(),
                             low = rgb(248, 203, 173, maxColorValue = 255),
                             mid = rgb(237,127, 52, maxColorValue = 255),
                             high = rgb(165, 0 , 33, maxColorValue = 255),
                             midpoint = 4)
    #"#74c476" 
    if (eff_disp_pts)
      p_list[[3]] = p_list[[3]] + geom_point(aes(group = .data$effort,
                                                 color = .data$effort))
    if (eff_disp_smooth)
      p_list[[3]] = p_list[[3]] + geom_smooth(aes(group = .data$effort, 
                                                  color = .data$effort),
                                              method = lm, se = FALSE)
  }
  
  if ('stat ~ effort' %in% display) {
    if (stat == 'b0')
      ylab = expression('intercept (' * italic(beta)[0] * ')')
    if (stat == 'b1')
      ylab = expression('slope (' * italic(beta)[1] * ')')
    if (stat == 'r2')
      ylab = expression(italic(R^2))
    if (stat == 'r')
      ylab = expression(italic(r))
    if (stat == 'f')
      ylab = expression(italic(F))
    p_list[[4]] = ggplot(subset(x$mod_df, x$mod_df$index == stat),
                         aes(.data$effort, .data$value)) + 
      geom_ribbon(aes(ymin = .data$low_value,
                      ymax = .data$high_value, fill = 'null'),
                  alpha = 0.25) +
      geom_line(aes(group = .data$index, color = 'observed')) +
      geom_hline(yintercept = 0, linetype = 'dashed') + 
      facet_wrap(. ~ test, scales = "free_x") +
      labs(y = ylab) +
      scale_color_manual(name = element_blank(),
                         values = c(observed = 'red')) +
      scale_fill_manual(name = element_blank(),
                        values = c(null = 'grey40'))
  }
  
  if (!is.null(scale_by)) { # change title of legend
    scale_by = ifelse(scale_by == 'indiv', '# of individuals', '# of plots')
    if (!is.null(p_list[[1]]))  
      p_list[[1]] = p_list[[1]] + labs(color = scale_by)
    if (!is.null(p_list[[3]])) 
      p_list[[3]] = p_list[[3]] + labs(color = scale_by)
    
    if (!is.null(p_list[[2]]))
      p_list[[2]] =  p_list[[2]] + labs(x = scale_by)
    if (!is.null(p_list[[4]]))
      p_list[[4]] =  p_list[[4]] + labs(x = scale_by)
    
  }
  
  if (grepl('x', log2)) {
    if (!is.null(p_list[[2]]))
      p_list[[2]] = p_list[[2]] + scale_x_continuous(trans = 'log2')
    if (!is.null(p_list[[4]]))
      p_list[[4]] = p_list[[4]] + scale_x_continuous(trans = 'log2')
  }
  
  if (grepl('y', log2)) {
    if (!is.null(p_list[[2]]))
      p_list[[2]] = p_list[[2]] + scale_y_continuous(trans = 'log2')
  }
  p_list = Filter(Negate(is.null), p_list)
  egg::ggarrange(plots = p_list)
}